# -*- coding: utf-8 -*-

"""A command-line DRY Python package builder

This package contains the source code to support the ``pyron`` Python
command-line tool for building and installing packages.

"""
from __future__ import absolute_import

__version__ = '0.1'
__testrunner__ = 'nose'
__author__ = 'Brandon Craig Rhodes <brandon@rhodesmill.org>'
__url__ = 'http://bitbucket.org/brandon/pyron/'

import email.utils, os.path, shutil, subprocess, sys
from optparse import OptionParser
from pprint import pformat

from .introspect import parse_project_init
from .readme import find_readme, inspect_readme
from .namespaces import NamespaceStack
from .scan import scan_package

def die(message):
    sys.stderr.write('pyron: ' + message + '\n')
    sys.exit(1)

join = os.path.join

usage = """\
usage: %prog build     - build the project in the current directory
       %prog python    - run an interpreter with this project in its PATH
       %prog run <cmd> - run one of your project console entry-points
       %prog register  - upload project metadata to PyPI
       %prog sdist     - generate a .tar.gz ready for distribution
       %prog bdist_egg - generate a binary egg for distribution"""

cmds = ['build', 'python', 'run', 'register', 'sdist', 'bdist_egg']

def main():
    parser = OptionParser(usage)
    (options, args) = parser.parse_args()

    if not args or args[0] not in cmds:
        parser.print_help()
        sys.exit(1)

    cmd = args[0]
    del args[0]

    base = '.' # TODO: allow command line to specify

    readme_path = find_readme(base)
    package_name, description, body = inspect_readme(readme_path)

    init_path = join(base, '__init__.py')
    values = parse_project_init(init_path)

    __author__ = values['__author__']
    author, author_email = email.utils.parseaddr(__author__)
    if not author:
        die('the __author__ defined in your __init__.py must include both'
            ' a name and an email address, like "Ed <ed@example.com>"')

    package_names = package_name.split('.')
    namespace_packages = [ '.'.join(package_names[:i])
                           for i in range(1, len(package_names)) ]

    if '__requires__' in values:
        # TODO: make sure it's a list
        requires = values['__requires__']
    else:
        requires = []

    facts = {}

    setup_args = dict(
        name = package_name,
        version = values['__version__'],
        description = description,
        long_description = body,
        author = author,
        author_email = author_email,
        packages = [ package_name ] + namespace_packages,
        #package_data = { package_name: ['README.txt'] },
        namespace_packages = namespace_packages,
        zip_safe = False,
        install_requires = requires,
        )

    if '__url__' in values:
        setup_args['url'] = values['__url__']

    #

    dotdir = join(base, '.pyron')

    if not os.path.exists(dotdir):
        os.system('virtualenv ' + dotdir)

    # Next, remove any pkg-info already present, since it will remember
    # things from our last run and make our results unpredictable.

    egg_info = join(dotdir, package_name + '.egg_info')
    if os.path.exists(egg_info):
        shutil.rmtree(egg_info)

    # Next, create a tree of parent namespace packages.  If already
    # present, then verify that it is correct; if verification fails,
    # then rebuild it.

    namespace_stack = NamespaceStack(dotdir, package_names)
    if not namespace_stack.check():
        namespace_stack.build()

    # Now that the namespace stack exists, we can introspect the
    # contents of this package like a real module.

    facts = scan_package(package_name, base, dotdir)

    if 'console_scripts' in facts and facts['console_scripts']:
        setup_args['entry_points'] = {
            'console_scripts': facts['console_scripts'],
            }

    #

    python = join(dotdir, 'bin', 'python')
    setup_py = join(dotdir, 'setup.py')

    f = open(setup_py, 'w')
    f.write('# Generated by pyron\nimport setuptools\n'
            'setuptools.setup(**\n%s\n)\n' % pformat(setup_args))
    f.close()

    # Make a copy of README.txt so that distutils can find it in its
    # standard location next to setup.py, instead of just in the project
    # source directory.
    shutil.copy('README.txt', dotdir)

    subprocess.check_call([ join('bin', 'python'), 'setup.py',
                            '-q', 'clean', 'develop' ],
                          cwd=dotdir)

    if cmd == 'build':
        pass # work has already been done, above
    elif cmd == 'python':
        os.execvp(python, [ python ] + sys.argv[2:])
    elif cmd == 'run':
        cmd = join(dotdir, 'bin', sys.argv[2])
        os.execvp(cmd, [ cmd ] + sys.argv[3:])
    #elif cmd == 'test':
    #    os.execvp(python, [ python ] + sys.argv[2:])
    elif cmd == 'register':
        subprocess.check_call([
                join('bin', 'python'), 'setup.py', '-q', sys.argv[1],
                ], cwd=dotdir)
    elif cmd in ['sdist', 'bdist_egg']:
        subprocess.check_call([
                join('bin', 'python'), 'setup.py', '-q'] + sys.argv[1:],
                              cwd=dotdir)
        for name in os.listdir(join(dotdir, 'dist')):
            shutil.move(join(dotdir, 'dist', name), base)
